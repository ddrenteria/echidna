<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/home/lafhis/Desktop/tesis/ours/echidna/uniswap/libraries/BitMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title BitMath</span>
  5 |     | <span class='neutral'>/// @dev This library provides functionality for computing bit properties of an unsigned integer</span>
  6 |     | <span class='unexecuted'>library BitMath {</span>
  7 |     | <span class='neutral'>    /// @notice Returns the index of the most significant bit of the number,</span>
  8 |     | <span class='neutral'>    ///     where the least significant bit is at index 0 and the most significant bit is at index 255</span>
  9 |     | <span class='neutral'>    /// @dev The function satisfies the property:</span>
 10 |     | <span class='neutral'>    ///     x &gt;= 2**mostSignificantBit(x) and x &lt; 2**(mostSignificantBit(x)+1)</span>
 11 |     | <span class='neutral'>    /// @param x the value for which to compute the most significant bit, must be greater than 0</span>
 12 |     | <span class='neutral'>    /// @return r the index of the most significant bit</span>
 13 | *   | <span class='executed'>    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {</span>
 14 | *   | <span class='executed'>        require(x &gt; 0);</span>
 15 |     | <span class='neutral'></span>
 16 | *   | <span class='executed'>        if (x &gt;= 0x100000000000000000000000000000000) {</span>
 17 | *   | <span class='executed'>            x &gt;&gt;= 128;</span>
 18 | *   | <span class='executed'>            r += 128;</span>
 19 |     | <span class='neutral'>        }</span>
 20 | *   | <span class='executed'>        if (x &gt;= 0x10000000000000000) {</span>
 21 | *   | <span class='executed'>            x &gt;&gt;= 64;</span>
 22 | *   | <span class='executed'>            r += 64;</span>
 23 |     | <span class='neutral'>        }</span>
 24 | *   | <span class='executed'>        if (x &gt;= 0x100000000) {</span>
 25 | *   | <span class='executed'>            x &gt;&gt;= 32;</span>
 26 | *   | <span class='executed'>            r += 32;</span>
 27 |     | <span class='neutral'>        }</span>
 28 | *   | <span class='executed'>        if (x &gt;= 0x10000) {</span>
 29 | *   | <span class='executed'>            x &gt;&gt;= 16;</span>
 30 | *   | <span class='executed'>            r += 16;</span>
 31 |     | <span class='neutral'>        }</span>
 32 | *   | <span class='executed'>        if (x &gt;= 0x100) {</span>
 33 | *   | <span class='executed'>            x &gt;&gt;= 8;</span>
 34 | *   | <span class='executed'>            r += 8;</span>
 35 |     | <span class='neutral'>        }</span>
 36 | *   | <span class='executed'>        if (x &gt;= 0x10) {</span>
 37 | *   | <span class='executed'>            x &gt;&gt;= 4;</span>
 38 | *   | <span class='executed'>            r += 4;</span>
 39 |     | <span class='neutral'>        }</span>
 40 | *   | <span class='executed'>        if (x &gt;= 0x4) {</span>
 41 | *   | <span class='executed'>            x &gt;&gt;= 2;</span>
 42 | *   | <span class='executed'>            r += 2;</span>
 43 |     | <span class='neutral'>        }</span>
 44 | *   | <span class='executed'>        if (x &gt;= 0x2) r += 1;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /// @notice Returns the index of the least significant bit of the number,</span>
 48 |     | <span class='neutral'>    ///     where the least significant bit is at index 0 and the most significant bit is at index 255</span>
 49 |     | <span class='neutral'>    /// @dev The function satisfies the property:</span>
 50 |     | <span class='neutral'>    ///     (x &amp; 2**leastSignificantBit(x)) != 0 and (x &amp; (2**(leastSignificantBit(x)) - 1)) == 0)</span>
 51 |     | <span class='neutral'>    /// @param x the value for which to compute the least significant bit, must be greater than 0</span>
 52 |     | <span class='neutral'>    /// @return r the index of the least significant bit</span>
 53 | *   | <span class='executed'>    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {</span>
 54 | *   | <span class='executed'>        require(x &gt; 0);</span>
 55 |     | <span class='neutral'></span>
 56 | *   | <span class='executed'>        r = 255;</span>
 57 | *   | <span class='executed'>        if (x &amp; type(uint128).max &gt; 0) {</span>
 58 | *   | <span class='executed'>            r -= 128;</span>
 59 |     | <span class='neutral'>        } else {</span>
 60 | *   | <span class='executed'>            x &gt;&gt;= 128;</span>
 61 |     | <span class='neutral'>        }</span>
 62 | *   | <span class='executed'>        if (x &amp; type(uint64).max &gt; 0) {</span>
 63 | *   | <span class='executed'>            r -= 64;</span>
 64 |     | <span class='neutral'>        } else {</span>
 65 | *   | <span class='executed'>            x &gt;&gt;= 64;</span>
 66 |     | <span class='neutral'>        }</span>
 67 | *   | <span class='executed'>        if (x &amp; type(uint32).max &gt; 0) {</span>
 68 | *   | <span class='executed'>            r -= 32;</span>
 69 |     | <span class='neutral'>        } else {</span>
 70 | *   | <span class='executed'>            x &gt;&gt;= 32;</span>
 71 |     | <span class='neutral'>        }</span>
 72 | *   | <span class='executed'>        if (x &amp; type(uint16).max &gt; 0) {</span>
 73 | *   | <span class='executed'>            r -= 16;</span>
 74 |     | <span class='neutral'>        } else {</span>
 75 | *   | <span class='executed'>            x &gt;&gt;= 16;</span>
 76 |     | <span class='neutral'>        }</span>
 77 | *   | <span class='executed'>        if (x &amp; type(uint8).max &gt; 0) {</span>
 78 | *   | <span class='executed'>            r -= 8;</span>
 79 |     | <span class='neutral'>        } else {</span>
 80 | *   | <span class='executed'>            x &gt;&gt;= 8;</span>
 81 |     | <span class='neutral'>        }</span>
 82 | *   | <span class='executed'>        if (x &amp; 0xf &gt; 0) {</span>
 83 | *   | <span class='executed'>            r -= 4;</span>
 84 |     | <span class='neutral'>        } else {</span>
 85 | *   | <span class='executed'>            x &gt;&gt;= 4;</span>
 86 |     | <span class='neutral'>        }</span>
 87 | *   | <span class='executed'>        if (x &amp; 0x3 &gt; 0) {</span>
 88 | *   | <span class='executed'>            r -= 2;</span>
 89 |     | <span class='neutral'>        } else {</span>
 90 | *   | <span class='executed'>            x &gt;&gt;= 2;</span>
 91 |     | <span class='neutral'>        }</span>
 92 | *   | <span class='executed'>        if (x &amp; 0x1 &gt; 0) r -= 1;</span>
 93 |     | <span class='neutral'>    }</span>
 94 |     | <span class='neutral'>}</span>
 95 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/lafhis/Desktop/tesis/ours/echidna/uniswap/test/BitMathEchidnaTest.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity =0.7.6;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../libraries/BitMath.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 | *   | <span class='executed'>contract BitMathEchidnaTest {</span>
  7 | *   | <span class='executed'>    function mostSignificantBitInvariant(uint256 input) external pure {</span>
  8 | *   | <span class='executed'>        uint8 msb = BitMath.mostSignificantBit(input);</span>
  9 | *   | <span class='executed'>        assert(input &gt;= (uint256(2)**msb));</span>
 10 | *   | <span class='executed'>        assert(msb == 255 || input &lt; uint256(2)**(msb + 1));</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 | *   | <span class='executed'>    function leastSignificantBitInvariant(uint256 input) external pure {</span>
 14 | *   | <span class='executed'>        uint8 lsb = BitMath.leastSignificantBit(input);</span>
 15 | *   | <span class='executed'>        assert(input &amp; (uint256(2)**lsb) != 0);</span>
 16 | *   | <span class='executed'>        assert(input &amp; (uint256(2)**lsb - 1) == 0);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />


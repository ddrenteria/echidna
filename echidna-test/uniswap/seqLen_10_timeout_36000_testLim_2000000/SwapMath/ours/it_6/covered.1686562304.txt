/home/lafhis/Desktop/tesis/ours/echidna/uniswap/libraries/FixedPoint96.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.4.0;
  3 |     | 
  4 |     | /// @title FixedPoint96
  5 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
  6 |     | /// @dev Used in SqrtPriceMath.sol
  7 |     | library FixedPoint96 {
  8 | *   |     uint8 internal constant RESOLUTION = 96;
  9 | *   |     uint256 internal constant Q96 = 0x1000000000000000000000000;
 10 |     | }
 11 |     | 

/home/lafhis/Desktop/tesis/ours/echidna/uniswap/libraries/FullMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.4.0 <0.8.0;
   3 |     | 
   4 |     | /// @title Contains 512-bit math functions
   5 |     | /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
   6 |     | /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
   7 |     | library FullMath {
   8 |     |     /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
   9 |     |     /// @param a The multiplicand
  10 |     |     /// @param b The multiplier
  11 |     |     /// @param denominator The divisor
  12 |     |     /// @return result The 256-bit result
  13 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
  14 | *   |     function mulDiv(
  15 |     |         uint256 a,
  16 |     |         uint256 b,
  17 |     |         uint256 denominator
  18 | *   |     ) internal pure returns (uint256 result) {
  19 |     |         // 512-bit multiply [prod1 prod0] = a * b
  20 |     |         // Compute the product mod 2**256 and mod 2**256 - 1
  21 |     |         // then use the Chinese Remainder Theorem to reconstruct
  22 |     |         // the 512 bit result. The result is stored in two 256
  23 |     |         // variables such that product = prod1 * 2**256 + prod0
  24 | *   |         uint256 prod0; // Least significant 256 bits of the product
  25 | *   |         uint256 prod1; // Most significant 256 bits of the product
  26 | *   |         assembly {
  27 | *   |             let mm := mulmod(a, b, not(0))
  28 | *   |             prod0 := mul(a, b)
  29 | *   |             prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  30 |     |         }
  31 |     | 
  32 |     |         // Handle non-overflow cases, 256 by 256 division
  33 | *   |         if (prod1 == 0) {
  34 | *   |             require(denominator > 0);
  35 |     |             assembly {
  36 | *   |                 result := div(prod0, denominator)
  37 |     |             }
  38 | *   |             return result;
  39 |     |         }
  40 |     | 
  41 |     |         // Make sure the result is less than 2**256.
  42 |     |         // Also prevents denominator == 0
  43 | *   |         require(denominator > prod1);
  44 |     | 
  45 |     |         ///////////////////////////////////////////////
  46 |     |         // 512 by 256 division.
  47 |     |         ///////////////////////////////////////////////
  48 |     | 
  49 |     |         // Make division exact by subtracting the remainder from [prod1 prod0]
  50 |     |         // Compute remainder using mulmod
  51 | *   |         uint256 remainder;
  52 |     |         assembly {
  53 | *   |             remainder := mulmod(a, b, denominator)
  54 |     |         }
  55 |     |         // Subtract 256 bit number from 512 bit number
  56 |     |         assembly {
  57 | *   |             prod1 := sub(prod1, gt(remainder, prod0))
  58 | *   |             prod0 := sub(prod0, remainder)
  59 |     |         }
  60 |     | 
  61 |     |         // Factor powers of two out of denominator
  62 |     |         // Compute largest power of two divisor of denominator.
  63 |     |         // Always >= 1.
  64 | *   |         uint256 twos = -denominator & denominator;
  65 |     |         // Divide denominator by power of two
  66 |     |         assembly {
  67 | *   |             denominator := div(denominator, twos)
  68 |     |         }
  69 |     | 
  70 |     |         // Divide [prod1 prod0] by the factors of two
  71 |     |         assembly {
  72 | *   |             prod0 := div(prod0, twos)
  73 |     |         }
  74 |     |         // Shift in bits from prod1 into prod0. For this we need
  75 |     |         // to flip `twos` such that it is 2**256 / twos.
  76 |     |         // If twos is zero, then it becomes one
  77 |     |         assembly {
  78 | *   |             twos := add(div(sub(0, twos), twos), 1)
  79 |     |         }
  80 | *   |         prod0 |= prod1 * twos;
  81 |     | 
  82 |     |         // Invert denominator mod 2**256
  83 |     |         // Now that denominator is an odd number, it has an inverse
  84 |     |         // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  85 |     |         // Compute the inverse by starting with a seed that is correct
  86 |     |         // correct for four bits. That is, denominator * inv = 1 mod 2**4
  87 | *   |         uint256 inv = (3 * denominator) ^ 2;
  88 |     |         // Now use Newton-Raphson iteration to improve the precision.
  89 |     |         // Thanks to Hensel's lifting lemma, this also works in modular
  90 |     |         // arithmetic, doubling the correct bits in each step.
  91 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**8
  92 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**16
  93 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**32
  94 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**64
  95 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**128
  96 | *   |         inv *= 2 - denominator * inv; // inverse mod 2**256
  97 |     | 
  98 |     |         // Because the division is now exact we can divide by multiplying
  99 |     |         // with the modular inverse of denominator. This will give us the
 100 |     |         // correct result modulo 2**256. Since the precoditions guarantee
 101 |     |         // that the outcome is less than 2**256, this is the final result.
 102 |     |         // We don't need to compute the high bits of the result and prod1
 103 |     |         // is no longer required.
 104 | *   |         result = prod0 * inv;
 105 | *   |         return result;
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
 109 |     |     /// @param a The multiplicand
 110 |     |     /// @param b The multiplier
 111 |     |     /// @param denominator The divisor
 112 |     |     /// @return result The 256-bit result
 113 | *   |     function mulDivRoundingUp(
 114 |     |         uint256 a,
 115 |     |         uint256 b,
 116 |     |         uint256 denominator
 117 | *   |     ) internal pure returns (uint256 result) {
 118 | *   |         result = mulDiv(a, b, denominator);
 119 | *   |         if (mulmod(a, b, denominator) > 0) {
 120 | *   |             require(result < type(uint256).max);
 121 | *   |             result++;
 122 |     |         }
 123 |     |     }
 124 |     | }
 125 |     | 

/home/lafhis/Desktop/tesis/ours/echidna/uniswap/libraries/LowGasSafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.7.0;
  3 |     | 
  4 |     | /// @title Optimized overflow and underflow safe math operations
  5 |     | /// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost
  6 |     | library LowGasSafeMath {
  7 |     |     /// @notice Returns x + y, reverts if sum overflows uint256
  8 |     |     /// @param x The augend
  9 |     |     /// @param y The addend
 10 |     |     /// @return z The sum of x and y
 11 | *   |     function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
 12 | *   |         require((z = x + y) >= x);
 13 |     |     }
 14 |     | 
 15 |     |     /// @notice Returns x - y, reverts if underflows
 16 |     |     /// @param x The minuend
 17 |     |     /// @param y The subtrahend
 18 |     |     /// @return z The difference of x and y
 19 |     |     function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
 20 |     |         require((z = x - y) <= x);
 21 |     |     }
 22 |     | 
 23 |     |     /// @notice Returns x * y, reverts if overflows
 24 |     |     /// @param x The multiplicand
 25 |     |     /// @param y The multiplier
 26 |     |     /// @return z The product of x and y
 27 |     |     function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
 28 |     |         require(x == 0 || (z = x * y) / x == y);
 29 |     |     }
 30 |     | 
 31 |     |     /// @notice Returns x + y, reverts if overflows or underflows
 32 |     |     /// @param x The augend
 33 |     |     /// @param y The addend
 34 |     |     /// @return z The sum of x and y
 35 |     |     function add(int256 x, int256 y) internal pure returns (int256 z) {
 36 |     |         require((z = x + y) >= x == (y >= 0));
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Returns x - y, reverts if overflows or underflows
 40 |     |     /// @param x The minuend
 41 |     |     /// @param y The subtrahend
 42 |     |     /// @return z The difference of x and y
 43 |     |     function sub(int256 x, int256 y) internal pure returns (int256 z) {
 44 |     |         require((z = x - y) <= x == (y >= 0));
 45 |     |     }
 46 |     | }
 47 |     | 

/home/lafhis/Desktop/tesis/ours/echidna/uniswap/libraries/SafeCast.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Safe casting methods
  5 |     | /// @notice Contains methods for safely casting between types
  6 |     | library SafeCast {
  7 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
  8 |     |     /// @param y The uint256 to be downcasted
  9 |     |     /// @return z The downcasted integer, now type uint160
 10 | *   |     function toUint160(uint256 y) internal pure returns (uint160 z) {
 11 | *   |         require((z = uint160(y)) == y);
 12 |     |     }
 13 |     | 
 14 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 15 |     |     /// @param y The int256 to be downcasted
 16 |     |     /// @return z The downcasted integer, now type int128
 17 |     |     function toInt128(int256 y) internal pure returns (int128 z) {
 18 |     |         require((z = int128(y)) == y);
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Cast a uint256 to a int256, revert on overflow
 22 |     |     /// @param y The uint256 to be casted
 23 |     |     /// @return z The casted integer, now type int256
 24 |     |     function toInt256(uint256 y) internal pure returns (int256 z) {
 25 |     |         require(y < 2**255);
 26 |     |         z = int256(y);
 27 |     |     }
 28 |     | }
 29 |     | 

/home/lafhis/Desktop/tesis/ours/echidna/uniswap/libraries/SqrtPriceMath.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | import './LowGasSafeMath.sol';
   5 |     | import './SafeCast.sol';
   6 |     | 
   7 |     | import './FullMath.sol';
   8 |     | import './UnsafeMath.sol';
   9 |     | import './FixedPoint96.sol';
  10 |     | 
  11 |     | /// @title Functions based on Q64.96 sqrt price and liquidity
  12 |     | /// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas
  13 |     | library SqrtPriceMath {
  14 |     |     using LowGasSafeMath for uint256;
  15 |     |     using SafeCast for uint256;
  16 |     | 
  17 |     |     /// @notice Gets the next sqrt price given a delta of token0
  18 |     |     /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least
  19 |     |     /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the
  20 |     |     /// price less in order to not send too much output.
  21 |     |     /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),
  22 |     |     /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).
  23 |     |     /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta
  24 |     |     /// @param liquidity The amount of usable liquidity
  25 |     |     /// @param amount How much of token0 to add or remove from virtual reserves
  26 |     |     /// @param add Whether to add or remove the amount of token0
  27 |     |     /// @return The price after adding or removing amount, depending on add
  28 | *   |     function getNextSqrtPriceFromAmount0RoundingUp(
  29 |     |         uint160 sqrtPX96,
  30 |     |         uint128 liquidity,
  31 |     |         uint256 amount,
  32 |     |         bool add
  33 | *   |     ) internal pure returns (uint160) {
  34 |     |         // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price
  35 | *   |         if (amount == 0) return sqrtPX96;
  36 | *   |         uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
  37 |     | 
  38 | *   |         if (add) {
  39 | *   |             uint256 product;
  40 | *   |             if ((product = amount * sqrtPX96) / amount == sqrtPX96) {
  41 | *   |                 uint256 denominator = numerator1 + product;
  42 | *   |                 if (denominator >= numerator1)
  43 |     |                     // always fits in 160 bits
  44 | *   |                     return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));
  45 |     |             }
  46 |     | 
  47 | *   |             return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));
  48 |     |         } else {
  49 | *   |             uint256 product;
  50 |     |             // if the product overflows, we know the denominator underflows
  51 |     |             // in addition, we must check that the denominator does not underflow
  52 | *   |             require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);
  53 | *   |             uint256 denominator = numerator1 - product;
  54 | *   |             return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     /// @notice Gets the next sqrt price given a delta of token1
  59 |     |     /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least
  60 |     |     /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the
  61 |     |     /// price less in order to not send too much output.
  62 |     |     /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity
  63 |     |     /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta
  64 |     |     /// @param liquidity The amount of usable liquidity
  65 |     |     /// @param amount How much of token1 to add, or remove, from virtual reserves
  66 |     |     /// @param add Whether to add, or remove, the amount of token1
  67 |     |     /// @return The price after adding or removing `amount`
  68 | *   |     function getNextSqrtPriceFromAmount1RoundingDown(
  69 |     |         uint160 sqrtPX96,
  70 |     |         uint128 liquidity,
  71 |     |         uint256 amount,
  72 |     |         bool add
  73 | *   |     ) internal pure returns (uint160) {
  74 |     |         // if we're adding (subtracting), rounding down requires rounding the quotient down (up)
  75 |     |         // in both cases, avoid a mulDiv for most inputs
  76 | *   |         if (add) {
  77 | *   |             uint256 quotient =
  78 |     |                 (
  79 | *   |                     amount <= type(uint160).max
  80 | *   |                         ? (amount << FixedPoint96.RESOLUTION) / liquidity
  81 | *   |                         : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)
  82 |     |                 );
  83 |     | 
  84 | *   |             return uint256(sqrtPX96).add(quotient).toUint160();
  85 |     |         } else {
  86 | *   |             uint256 quotient =
  87 |     |                 (
  88 | *   |                     amount <= type(uint160).max
  89 | *   |                         ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)
  90 | *   |                         : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)
  91 |     |                 );
  92 |     | 
  93 | *   |             require(sqrtPX96 > quotient);
  94 |     |             // always fits 160 bits
  95 | *   |             return uint160(sqrtPX96 - quotient);
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /// @notice Gets the next sqrt price given an input amount of token0 or token1
 100 |     |     /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds
 101 |     |     /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount
 102 |     |     /// @param liquidity The amount of usable liquidity
 103 |     |     /// @param amountIn How much of token0, or token1, is being swapped in
 104 |     |     /// @param zeroForOne Whether the amount in is token0 or token1
 105 |     |     /// @return sqrtQX96 The price after adding the input amount to token0 or token1
 106 | *   |     function getNextSqrtPriceFromInput(
 107 |     |         uint160 sqrtPX96,
 108 |     |         uint128 liquidity,
 109 |     |         uint256 amountIn,
 110 |     |         bool zeroForOne
 111 | *   |     ) internal pure returns (uint160 sqrtQX96) {
 112 | *   |         require(sqrtPX96 > 0);
 113 | *   |         require(liquidity > 0);
 114 |     | 
 115 |     |         // round to make sure that we don't pass the target price
 116 | *   |         return
 117 | *   |             zeroForOne
 118 | *   |                 ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)
 119 | *   |                 : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
 120 |     |     }
 121 |     | 
 122 |     |     /// @notice Gets the next sqrt price given an output amount of token0 or token1
 123 |     |     /// @dev Throws if price or liquidity are 0 or the next price is out of bounds
 124 |     |     /// @param sqrtPX96 The starting price before accounting for the output amount
 125 |     |     /// @param liquidity The amount of usable liquidity
 126 |     |     /// @param amountOut How much of token0, or token1, is being swapped out
 127 |     |     /// @param zeroForOne Whether the amount out is token0 or token1
 128 |     |     /// @return sqrtQX96 The price after removing the output amount of token0 or token1
 129 | *   |     function getNextSqrtPriceFromOutput(
 130 |     |         uint160 sqrtPX96,
 131 |     |         uint128 liquidity,
 132 |     |         uint256 amountOut,
 133 |     |         bool zeroForOne
 134 | *   |     ) internal pure returns (uint160 sqrtQX96) {
 135 | *   |         require(sqrtPX96 > 0);
 136 | *   |         require(liquidity > 0);
 137 |     | 
 138 |     |         // round to make sure that we pass the target price
 139 | *   |         return
 140 | *   |             zeroForOne
 141 | *   |                 ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)
 142 | *   |                 : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
 143 |     |     }
 144 |     | 
 145 |     |     /// @notice Gets the amount0 delta between two prices
 146 |     |     /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),
 147 |     |     /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))
 148 |     |     /// @param sqrtRatioAX96 A sqrt price
 149 |     |     /// @param sqrtRatioBX96 Another sqrt price
 150 |     |     /// @param liquidity The amount of usable liquidity
 151 |     |     /// @param roundUp Whether to round the amount up or down
 152 |     |     /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices
 153 | *   |     function getAmount0Delta(
 154 |     |         uint160 sqrtRatioAX96,
 155 |     |         uint160 sqrtRatioBX96,
 156 |     |         uint128 liquidity,
 157 |     |         bool roundUp
 158 | *   |     ) internal pure returns (uint256 amount0) {
 159 | *   |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 160 |     | 
 161 | *   |         uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
 162 | *   |         uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;
 163 |     | 
 164 | *   |         require(sqrtRatioAX96 > 0);
 165 |     | 
 166 | *   |         return
 167 | *   |             roundUp
 168 | *   |                 ? UnsafeMath.divRoundingUp(
 169 | *   |                     FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),
 170 | *   |                     sqrtRatioAX96
 171 |     |                 )
 172 | *   |                 : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;
 173 |     |     }
 174 |     | 
 175 |     |     /// @notice Gets the amount1 delta between two prices
 176 |     |     /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))
 177 |     |     /// @param sqrtRatioAX96 A sqrt price
 178 |     |     /// @param sqrtRatioBX96 Another sqrt price
 179 |     |     /// @param liquidity The amount of usable liquidity
 180 |     |     /// @param roundUp Whether to round the amount up, or down
 181 |     |     /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices
 182 | *   |     function getAmount1Delta(
 183 |     |         uint160 sqrtRatioAX96,
 184 |     |         uint160 sqrtRatioBX96,
 185 |     |         uint128 liquidity,
 186 |     |         bool roundUp
 187 | *   |     ) internal pure returns (uint256 amount1) {
 188 | *   |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 189 |     | 
 190 | *   |         return
 191 | *   |             roundUp
 192 | *   |                 ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)
 193 | *   |                 : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
 194 |     |     }
 195 |     | 
 196 |     |     /// @notice Helper that gets signed token0 delta
 197 |     |     /// @param sqrtRatioAX96 A sqrt price
 198 |     |     /// @param sqrtRatioBX96 Another sqrt price
 199 |     |     /// @param liquidity The change in liquidity for which to compute the amount0 delta
 200 |     |     /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices
 201 |     |     function getAmount0Delta(
 202 |     |         uint160 sqrtRatioAX96,
 203 |     |         uint160 sqrtRatioBX96,
 204 |     |         int128 liquidity
 205 |     |     ) internal pure returns (int256 amount0) {
 206 |     |         return
 207 |     |             liquidity < 0
 208 |     |                 ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
 209 |     |                 : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
 210 |     |     }
 211 |     | 
 212 |     |     /// @notice Helper that gets signed token1 delta
 213 |     |     /// @param sqrtRatioAX96 A sqrt price
 214 |     |     /// @param sqrtRatioBX96 Another sqrt price
 215 |     |     /// @param liquidity The change in liquidity for which to compute the amount1 delta
 216 |     |     /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices
 217 |     |     function getAmount1Delta(
 218 |     |         uint160 sqrtRatioAX96,
 219 |     |         uint160 sqrtRatioBX96,
 220 |     |         int128 liquidity
 221 |     |     ) internal pure returns (int256 amount1) {
 222 |     |         return
 223 |     |             liquidity < 0
 224 |     |                 ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
 225 |     |                 : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
 226 |     |     }
 227 |     | }
 228 |     | 

/home/lafhis/Desktop/tesis/ours/echidna/uniswap/libraries/SwapMath.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.5.0;
   3 |     | 
   4 |     | import './FullMath.sol';
   5 |     | import './SqrtPriceMath.sol';
   6 |     | 
   7 |     | /// @title Computes the result of a swap within ticks
   8 |     | /// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.
   9 |     | library SwapMath {
  10 |     |     /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap
  11 |     |     /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive
  12 |     |     /// @param sqrtRatioCurrentX96 The current sqrt price of the pool
  13 |     |     /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred
  14 |     |     /// @param liquidity The usable liquidity
  15 |     |     /// @param amountRemaining How much input or output amount is remaining to be swapped in/out
  16 |     |     /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip
  17 |     |     /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target
  18 |     |     /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap
  19 |     |     /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap
  20 |     |     /// @return feeAmount The amount of input that will be taken as a fee
  21 | *   |     function computeSwapStep(
  22 |     |         uint160 sqrtRatioCurrentX96,
  23 |     |         uint160 sqrtRatioTargetX96,
  24 |     |         uint128 liquidity,
  25 |     |         int256 amountRemaining,
  26 |     |         uint24 feePips
  27 |     |     )
  28 |     |         internal
  29 |     |         pure
  30 |     |         returns (
  31 | *   |             uint160 sqrtRatioNextX96,
  32 | *   |             uint256 amountIn,
  33 | *   |             uint256 amountOut,
  34 | *   |             uint256 feeAmount
  35 |     |         )
  36 |     |     {
  37 | *   |         bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;
  38 | *   |         bool exactIn = amountRemaining >= 0;
  39 |     | 
  40 | *   |         if (exactIn) {
  41 | *   |             uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);
  42 | *   |             amountIn = zeroForOne
  43 | *   |                 ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)
  44 | *   |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);
  45 | *   |             if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;
  46 |     |             else
  47 | *   |                 sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(
  48 | *   |                     sqrtRatioCurrentX96,
  49 | *   |                     liquidity,
  50 | *   |                     amountRemainingLessFee,
  51 | *   |                     zeroForOne
  52 |     |                 );
  53 |     |         } else {
  54 | *   |             amountOut = zeroForOne
  55 | *   |                 ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)
  56 | *   |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);
  57 | *   |             if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;
  58 |     |             else
  59 | *   |                 sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(
  60 | *   |                     sqrtRatioCurrentX96,
  61 | *   |                     liquidity,
  62 | *   |                     uint256(-amountRemaining),
  63 | *   |                     zeroForOne
  64 |     |                 );
  65 |     |         }
  66 |     | 
  67 | *   |         bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;
  68 |     | 
  69 |     |         // get the input/output amounts
  70 | *   |         if (zeroForOne) {
  71 | *   |             amountIn = max && exactIn
  72 | *   |                 ? amountIn
  73 | *   |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
  74 | *   |             amountOut = max && !exactIn
  75 | *   |                 ? amountOut
  76 | *   |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);
  77 |     |         } else {
  78 | *   |             amountIn = max && exactIn
  79 | *   |                 ? amountIn
  80 | *   |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);
  81 | *   |             amountOut = max && !exactIn
  82 | *   |                 ? amountOut
  83 | *   |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);
  84 |     |         }
  85 |     | 
  86 |     |         // cap the output amount to not exceed the remaining output amount
  87 | *   |         if (!exactIn && amountOut > uint256(-amountRemaining)) {
  88 | *   |             amountOut = uint256(-amountRemaining);
  89 |     |         }
  90 |     | 
  91 | *   |         if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {
  92 |     |             // we didn't reach the target, so take the remainder of the maximum input as fee
  93 | *   |             feeAmount = uint256(amountRemaining) - amountIn;
  94 |     |         } else {
  95 | *   |             feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);
  96 |     |         }
  97 |     |     }
  98 |     | }
  99 |     | 

/home/lafhis/Desktop/tesis/ours/echidna/uniswap/libraries/UnsafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Math functions that do not check inputs or outputs
  5 |     | /// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks
  6 |     | library UnsafeMath {
  7 |     |     /// @notice Returns ceil(x / y)
  8 |     |     /// @dev division by 0 has unspecified behavior, and must be checked externally
  9 |     |     /// @param x The dividend
 10 |     |     /// @param y The divisor
 11 |     |     /// @return z The quotient, ceil(x / y)
 12 | *   |     function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
 13 | *   |         assembly {
 14 | *   |             z := add(div(x, y), gt(mod(x, y), 0))
 15 |     |         }
 16 |     |     }
 17 |     | }
 18 |     | 

/home/lafhis/Desktop/tesis/ours/echidna/uniswap/test/SwapMathEchidnaTest.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity =0.7.6;
  3 |     | 
  4 |     | import '../libraries/SwapMath.sol';
  5 |     | 
  6 | *   | contract SwapMathEchidnaTest {
  7 | *   |     function checkComputeSwapStepInvariants(
  8 |     |         uint160 sqrtPriceRaw,
  9 |     |         uint160 sqrtPriceTargetRaw,
 10 |     |         uint128 liquidity,
 11 |     |         int256 amountRemaining,
 12 |     |         uint24 feePips
 13 |     |     ) external pure {
 14 | *   |         require(sqrtPriceRaw > 0);
 15 | *   |         require(sqrtPriceTargetRaw > 0);
 16 | *   |         require(feePips > 0);
 17 | *   |         require(feePips < 1e6);
 18 |     | 
 19 | *   |         (uint160 sqrtQ, uint256 amountIn, uint256 amountOut, uint256 feeAmount) =
 20 | *   |             SwapMath.computeSwapStep(sqrtPriceRaw, sqrtPriceTargetRaw, liquidity, amountRemaining, feePips);
 21 |     | 
 22 | *   |         assert(amountIn <= type(uint256).max - feeAmount);
 23 |     | 
 24 | *   |         if (amountRemaining < 0) {
 25 | *   |             assert(amountOut <= uint256(-amountRemaining));
 26 |     |         } else {
 27 | *   |             assert(amountIn + feeAmount <= uint256(amountRemaining));
 28 |     |         }
 29 |     | 
 30 | *   |         if (sqrtPriceRaw == sqrtPriceTargetRaw) {
 31 | *   |             assert(amountIn == 0);
 32 | *   |             assert(amountOut == 0);
 33 | *   |             assert(feeAmount == 0);
 34 | *   |             assert(sqrtQ == sqrtPriceTargetRaw);
 35 |     |         }
 36 |     | 
 37 |     |         // didn't reach price target, entire amount must be consumed
 38 | *   |         if (sqrtQ != sqrtPriceTargetRaw) {
 39 | *   |             if (amountRemaining < 0) assert(amountOut == uint256(-amountRemaining));
 40 | *   |             else assert(amountIn + feeAmount == uint256(amountRemaining));
 41 |     |         }
 42 |     | 
 43 |     |         // next price is between price and price target
 44 | *   |         if (sqrtPriceTargetRaw <= sqrtPriceRaw) {
 45 | *   |             assert(sqrtQ <= sqrtPriceRaw);
 46 | *   |             assert(sqrtQ >= sqrtPriceTargetRaw);
 47 |     |         } else {
 48 | *   |             assert(sqrtQ >= sqrtPriceRaw);
 49 | *   |             assert(sqrtQ <= sqrtPriceTargetRaw);
 50 |     |         }
 51 |     |     }
 52 |     | }
 53 |     | 

